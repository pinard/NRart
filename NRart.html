<html><head><title>R: NRart Newton-Raphson art</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for NRart {NRart}"><tr><td>NRart {NRart}</td><td align="right">R Documentation</td></tr></table>
<h2>NRart Newton-Raphson art</h2>


<h3>Description</h3>

<p>
Produce 2-D images or movies out of mathematical functions.
</p>
<p>
To to so, apply a few iterations of Newton-Raphson method to each
point of a complex plane.
</p>


<h3>Usage</h3>

<pre>
  nr.image(expr, centre = c(0, 0), zoom = 1,
           xrange=c(centre[1]-zoom, centre[1]+zoom),
           yrange=c(centre[2]-zoom, centre[2]+zoom),
           points = 150, steps = 5, each, display = image,
           main = deparse(substitute(expr)), ...)
  nr.movie(expr, time.name, time.values, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>expr</code></td>
<td>
Symbolic expression of the mathematical function to render</td></tr>
<tr valign="top"><td><code>centre</code></td>
<td>
Vector for the coordinates of grid centre</td></tr>
<tr valign="top"><td><code>zoom</code></td>
<td>
Domain interval from <code>centre</code> to grid side</td></tr>
<tr valign="top"><td><code>xrange</code></td>
<td>
Vector giving minimum and maximum real parts for the grid</td></tr>
<tr valign="top"><td><code>yrange</code></td>
<td>
Vector giving minimum and maximum imaginary parts for the grid</td></tr>
<tr valign="top"><td><code>points</code></td>
<td>
Number of points along grid side</td></tr>
<tr valign="top"><td><code>steps</code></td>
<td>
Number of Newton-Raphson iterations</td></tr>
<tr valign="top"><td><code>each</code></td>
<td>
Frequency, in steps, for producing intermediate images</td></tr>
<tr valign="top"><td><code>display</code></td>
<td>
Function producing one image</td></tr>
<tr valign="top"><td><code>main</code></td>
<td>
Image title</td></tr>
<tr valign="top"><td><code>time.name</code></td>
<td>
String giving the animation parameter within <code>expr</code></td></tr>
<tr valign="top"><td><code>time.values</code></td>
<td>
Vector of values to be taken by the animation parameter</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
Options being transmitted down to sub-functions</td></tr>
</table>

<h3>Details</h3>

<p>
These functions apply one or more Newton-Raphson iteration steps to
<code>expr</code>, as a way of approaching roots (or zeroes) of the represented
mathematical function.
</p>
<p>
The first argument <code>expr</code> is the mathematical formula, the one
for which we are seeking zeroes.  That expression should use only one
&ldquo;unknown&rdquo; variable (for <code>nr.image</code>) or one unknown and one
parameter (for <code>nr.movie</code>).  It should be symbolically derivable
respective to its unknown.
</p>
<p>
Produced images or movies represent a square region in the complex
plane, having a side of <i>2*zoom</i> and centred on the origin, by
default.  Increasing <code>zoom</code> over one zooms out, decreasing it
towards zero zooms in.  Instead of specifying <code>centre</code> and
<code>zoom</code>, one may explicit <code>xrange</code> and <code>yrange</code>, in
which case the represented region is not necessarily square.
</p>
<p>
That region is to be displayed as <i>points^2</i> pixels.  So,
<code>points</code> gives the number of points in the horizontal or vertical
directions.  While playing with the formula and doing quick testing, a
lower value for <code>points</code> makes the rendering much speedier, but
the result is also more rough.  Make it a few hundreds for the final
pass.
</p>
<p>
There are <code>steps</code> Newton-Raphson iterations for each pixel
before producing the frame.  More steps yield more precision, and a
better classification of points toward their associate root.  So,
a higher value for <code>steps</code> translates into crisper or sharper
boundaries between colours.  A low value has the effect of producing
more progressive (or &ldquo;ramp&rdquo;ed) transitions between colors.
</p>
<p>
If <code>each</code> has been provided, an intermediate image is produced at
every <code>each</code> steps.  Using <SAMP>each=1</SAMP>, say, <code>nr.image</code>
shows the progressive sharpening of the resolution by displaying each
step, while Newton-Raphson iterations go and fractals develop.
</p>
<p>
For <code>nr.movie</code>, option <code>time.name</code> is a string naming the
parameter in the mathematical formula, and <code>time.values</code> gives
the successive values taken by this parameter for each produced movie
frame, thus producing the animation.  For the animation to endlessly
repeat in a smooth way, the formula should be periodic over its
parameter, and one should be careful to exclude the last frame if it
were to be equal to the first.  For example, for 120 animation frames
over a <i>pi</i> period, one may use <SAMP>time.values=seq(0, pi,
length=121)[-1]</SAMP>.
</p>
<p>
By default, the <code>image</code> function is used to display the
result, but this can be changed using the <code>display</code> option for
any function accepting a matrix of floating values.  Internally,
<code>nr.image</code> (which is also called by the others) uses <code>Arg</code>
for turning complex values into floating values before calling the
displaying function.
</p>


<h3>Value</h3>

<p>
Functions return the final matrix of complex numbers.</p>

<h3>Note</h3>

<p>
The basic idea is simple.
<ul>
<li>The equation <i>f(x) = 0</i> has one or many solutions, which
may be real or complex numbers.  A polynomial of degree <i>N</i>
has exactly <i>N</i> solutions (yet, as some solutions may coincide,
people might prefer to say that such a polynomial has at least 1,
and at most <i>N</i> solutions).
<li>There are really many ways to seek out for zeroes of a mathematical
function, and each method opens the door to various pictures which may
be visually interesting.  The Newton-Raphson is simple and well known,
and productive enough already, artistically speaking!
<li>Starting from a point in the complex plane, Newton-Raphson method
may diverge, oscillate, or converge.  When it converges, it is towards
one of the root for the function.  Different starting points may yield
different roots.  If we associate one colour to each possible
root, one may also colour any starting point with the colour of root
yielded by that point, or let the point uncoloured if there is no
convergence.
</ul>

<p>
The boundary between colours really often (but not always) has fractal
nature.  For exploring such boundaries, you may need to compute
really many points, and many Newton-Raphson iterations, so it may be
computationally intensive.
</p>
<p>
A few problems arise when one wants to colour points, however:
</p>

<ul>
<li>The number of solutions is not always known in advance, when one
escapes the realm of polynomials.  So, one may not always fix a
colour palette before starting computing everything.
<li>The number of Newton-Raphson iterations to decide convergence, and
identify the convergence point, is not always small, even if usually.
</ul>

<p>
As all points of the complex plane more or less collapse around roots,
which are limiting values, the problem might be the attribution of
colours for any complex value.  Then, as iterations go, colours of
the complex plane will collapse into regions surrounding roots, which
are then limiting colours for the convergence process.  Under this
approach, we can have displayable results without computing much, and
more computation will then increase the sharpness of colour separation.
</p>
<p>
The current algorithm merely maps colours to the argument (angle) of
the complex number.  This means that if two roots are aligned as seen
from the origin (they have the same angle), they will have the same
colour and so, will not be distinguished in the produced display.  The
algorithm could just as well have used other complex to real mappings,
yet the package does not offer that flexibility as it stands.
</p>
<p>
To produce a smooth animation, one may inject a parameter in the
mathematical formula, and then vary the parameter value in a smooth way.
</p>
<p>
Since <code>nr.image</code>, which is called by <code>nr.movie</code> under the
scene, computes a matrix of arguments of complex numbers, the range of
results may theoretically go from <i>-pi</i> to <i>+pi</i>.
Some frames of the animation may use only part of that range, and not
always the same part: the <code>image</code> function should not itself
decide the mapping of values to colours from a variable range from
frame to frame, it is nicer to have colours mapped fixed to values
for the whole animation.  An option <SAMP>zlim=c(-pi,pi)</SAMP>, which gets
transmitted down to function <code>image</code>, solves this particular
problem.
</p>
<p>
Another possible problem might arise from the fact that argument of
complex numbers are angles, and <i>-pi</i> and <i>+pi</i>
&ldquo;touch&rdquo; each other.  This might create sharp transitions
in the colouring, which may be either welcome or not.  When not,
it is better to use a cyclic ramp of colours, through an option
like <SAMP>col=rainbow(64)</SAMP>, which gets transmitted down to the
<code>image</code> function.
</p>


<h3>Author(s)</h3>

<p>
Francois Pinard <a href="mailto:pinard@iro.umontreal.ca">pinard@iro.umontreal.ca</a>
</p>


<h3>References</h3>

<p>
This tool was inspired by a conference by Bahaman Kalantari (Rutgers
University) while visiting Concordia University (Montreal), on 2005-04-05.
See <a href="http://www.polynomiography.com/">http://www.polynomiography.com/</a>.
</p>
<p>
A few examples of animations generated with this tool may be seen at
<a href="http://pinard.progiciels-bpi.ca/plaisirs/NRart/">http://pinard.progiciels-bpi.ca/plaisirs/NRart/</a>.
</p>
<p>
Others have done similar works, using other languages.  For example,
see <a href="http://www.chiark.greenend.org.uk/~sgtatham/newton/">http://www.chiark.greenend.org.uk/~sgtatham/newton/</a>.
</p>


<h3>See Also</h3>

<p>
<code><a href="../../graphics/html/image.html">image</a></code>
<code><a href="../../stats/html/deriv.html">D</a></code>
</p>


<h3>Examples</h3>

<pre>
  nr.image(x^3 - sqrt(x) - 1, points=300)
  nr.image(x^3 - sqrt(x) - 1, steps=6, points=50, display=filled.contour)
  nr.movie(x^3 - time, 'time', 1:5, steps=3, col=rainbow(15))
</pre>



<hr><div align="center">[Package <em>NRart</em> version 0.0 <a href="00Index.html">Index]</a></div>

</body></html>
